package com.wistron.demo.tool.teddybear.scene.voiceactivation;import android.media.AudioRecord;import android.util.Log;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class ListenAudioRecorder {    public static final int BITS_PER_SAMPLE = 16;    public static final short NUM_CHANNELS = (short) 1;    public static final int SAMPLE_RATE = 16000;    private static final String TAG = "ListenAudioRecorder";    public static final int TIMER_INTERVAL = 120;    private AudioRecord audioRecorder;    private int bufferSize;    private int framePeriod;    private Thread recordingThread;    private State state;    private String tempFilePath;    public enum State {        INITIALIZING,        READY,        RECORDING,        ERROR,        STOPPED    }    public static ListenAudioRecorder getInstance() {        return new ListenAudioRecorder(1, SAMPLE_RATE, BITS_PER_SAMPLE, 2);    }    public static ListenAudioRecorder getInstance(int inSessionId) {        return new ListenAudioRecorder(1, SAMPLE_RATE, BITS_PER_SAMPLE, 2);    }    public ListenAudioRecorder(int inAudioSource, int inSampleRate, int inChannelConfig, int inAudioFormat) {        this.audioRecorder = null;        this.tempFilePath = SVAGlobal.PATH_RECORDINGS_TEMP_FILE;        this.recordingThread = null;        Log.v(TAG, "ListenAudioRecorder constructor");        try {            this.framePeriod = (inSampleRate * TIMER_INTERVAL) / 1000;            this.bufferSize = (((this.framePeriod * 2) * BITS_PER_SAMPLE) * 1) / 8;            if (this.bufferSize < AudioRecord.getMinBufferSize(inSampleRate, inChannelConfig, inAudioFormat)) {                this.bufferSize = AudioRecord.getMinBufferSize(inSampleRate, inChannelConfig, inAudioFormat);                this.framePeriod = this.bufferSize / 4;                Log.v(TAG, "Increasing buffer size to " + Integer.toString(this.bufferSize));            }            this.audioRecorder = new AudioRecord(inAudioSource, inSampleRate, inChannelConfig, inAudioFormat, this.bufferSize);            Log.v(TAG, "ListenAudioRecorder constructor: constructed");            if (this.audioRecorder.getState() != 1) {                throw new Exception("AudioRecord initialization failed");            }            this.state = State.INITIALIZING;            Log.v(TAG, "ListenAudioRecorder constructor: finished");        } catch (Exception e) {            if (e.getMessage() != null) {                Log.e(TAG, e.getMessage());            } else {                Log.e(TAG, "Unknown error occured while initializing recording");            }            this.state = State.ERROR;        }    }    public State getState() {        return this.state;    }    public void start() {        Log.v(TAG, "start");        Log.v(TAG, "start: in state = READY");        this.audioRecorder.startRecording();        Log.v(TAG, "start: started recording, audioRecorder state= " + this.audioRecorder.getRecordingState());        this.state = State.RECORDING;        this.recordingThread = new Thread(new Runnable() {            @Override            public void run() {                ListenAudioRecorder.this.writeAudioDataToFile();            }        }, "AudioRecorder Thread");        this.recordingThread.start();    }    private void writeAudioDataToFile() {        Log.v(TAG, "writeAudioDataToFile");        FileOutputStream os = null;        try {            os = new FileOutputStream(this.tempFilePath, false);        } catch (FileNotFoundException e) {            e.printStackTrace();        }        if (os != null) {            while (this.state == State.RECORDING) {                byte[] data = new byte[this.bufferSize];                int read = this.audioRecorder.read(data, 0, this.bufferSize);                Log.v(TAG, "writeAudioDataToFile: read = " + read);                if (-3 != read) {                    try {                        os.write(data);                    } catch (IOException e2) {                        e2.printStackTrace();                    }                }            }            try {                os.close();            } catch (IOException e22) {                e22.printStackTrace();            }        }    }    public void stop(String inFilePath) {        Log.v(TAG, "stop");        if (this.state == State.RECORDING) {            this.audioRecorder.stop();            this.audioRecorder.release();            this.state = State.STOPPED;            copyWavFile(this.tempFilePath, inFilePath);            deleteTempFile();            return;        }        Log.v(TAG, "stop() called but not recording");        this.state = State.ERROR;    }    private void copyWavFile(String inFilename, String outFilename) {        byte[] data = new byte[this.bufferSize];        try {            FileInputStream in = new FileInputStream(inFilename);            FileOutputStream out = new FileOutputStream(outFilename);            long totalAudioLen = in.getChannel().size();            out.write(Utils.getWavHeader(totalAudioLen, totalAudioLen + 44), 0, 44);            while (in.read(data) != -1) {                out.write(data);            }            in.close();            out.close();        } catch (Exception e) {            Log.i(TAG, "ListenAudioRecorder copyWavFile e: " + e.getMessage());            e.printStackTrace();        }        SVAGlobal.getInstance().addUserRecording();    }    private void deleteTempFile() {        Utils.deleteFile(this.tempFilePath);    }}